{"version":3,"file":"extractor.mjs","sources":["../../../src/utilities/extractor.ts"],"sourcesContent":["/**\n * Extractable\n */\nexport type CaptureableCharacterPattern = string | RegExp | CaptureableCharacterType;\n\nexport enum CaptureableCharacterType {\n  HIRAGANA,\n  KUTOUTEN,\n  CHOUON,\n  KAGIKAKKO,\n  ZENKAKU_SPACE,\n  HANKAKU_SPACE,\n  ZENKAKU_ALPHABET,\n  HANKAKU_ALPHABET,\n  ZENKAKU_NUMBER,\n  HANKAKU_NUMBER,\n  ZENKAKU_1BYTE_SYMBOL,\n  HANKAKU_1BYTE_SYMBOL,\n}\n\nexport const CaptureableCharacterMap: Record<CaptureableCharacterType, RegExp> = {\n  [CaptureableCharacterType.HIRAGANA]: /[ぁ-ん]/g,\n  [CaptureableCharacterType.KUTOUTEN]: /[、。]/g,\n  [CaptureableCharacterType.CHOUON]: /[ー]/g,\n  [CaptureableCharacterType.KAGIKAKKO]: /[「」]/g,\n  /* eslint-disable-next-line no-irregular-whitespace */\n  [CaptureableCharacterType.ZENKAKU_SPACE]: /[　]/g,\n  [CaptureableCharacterType.HANKAKU_SPACE]: /[ ]/g,\n  [CaptureableCharacterType.ZENKAKU_ALPHABET]: /[Ａ-Ｚａ-ｚ]/g,\n  [CaptureableCharacterType.HANKAKU_ALPHABET]: /[A-Za-z]/g,\n  [CaptureableCharacterType.ZENKAKU_NUMBER]: /[０-９]/g,\n  [CaptureableCharacterType.HANKAKU_NUMBER]: /[0-9]/g,\n  [CaptureableCharacterType.ZENKAKU_1BYTE_SYMBOL]: /[！＂＃＄％＆＇（）＊＋，－．／：；＜＝＞？＠［￥］＾＿“｛｜｝～]/g,\n  /* eslint-disable-next-line no-useless-escape*/\n  [CaptureableCharacterType.HANKAKU_1BYTE_SYMBOL]: /[!\"#$%&'()*+,-.\\/:;<=>?@[\\\\]^_`{|}~]/g,\n}\n\nexport type ExtractorInput = {\n  input: string;\n  patterns?: CaptureableCharacterPattern | CaptureableCharacterPattern[];\n}\nexport function extractor({\n  input,\n  patterns = CaptureableCharacterType.HIRAGANA,\n}: ExtractorInput): string {\n  const sources: string[] = []\n  const patternParser = (pattern: CaptureableCharacterPattern) => {\n    if (typeof pattern === 'string') {\n      sources.push('[' + pattern + ']')\n    } else if (pattern instanceof RegExp) {\n      sources.push(pattern.source)\n    } else {\n      sources.push(CaptureableCharacterMap[pattern].source)\n    }\n  }\n\n  if (Array.isArray(patterns)) {\n    for (const pattern of patterns) {\n      patternParser(pattern)\n    }\n  } else {\n    patternParser(patterns)\n  }\n  if (sources.length === 0) {\n    return input\n  }\n\n  const regExp = new RegExp(sources.join('|'), 'g')\n  const filter = input.replace(regExp, '')\n  if (filter.length === 0) {\n    return input\n  }\n  return input.replace(\n    new RegExp('[' + filter + ']', 'g'),\n    '',\n  )\n}\n"],"names":["CaptureableCharacterType","CaptureableCharacterType2","CaptureableCharacterMap","extractor","input","patterns","sources","patternParser","pattern","regExp","filter"],"mappings":"AAKY,IAAAA,sBAAAA,OACVA,EAAAC,EAAA,WAAA,CAAA,IAAA,YACAD,EAAAC,EAAA,WAAA,CAAA,IAAA,YACAD,EAAAC,EAAA,SAAA,CAAA,IAAA,UACAD,EAAAC,EAAA,YAAA,CAAA,IAAA,aACAD,EAAAC,EAAA,gBAAA,CAAA,IAAA,iBACAD,EAAAC,EAAA,gBAAA,CAAA,IAAA,iBACAD,EAAAC,EAAA,mBAAA,CAAA,IAAA,oBACAD,EAAAC,EAAA,mBAAA,CAAA,IAAA,oBACAD,EAAAC,EAAA,iBAAA,CAAA,IAAA,kBACAD,EAAAC,EAAA,iBAAA,CAAA,IAAA,kBACAD,EAAAC,EAAA,uBAAA,EAAA,IAAA,wBACAD,EAAAC,EAAA,uBAAA,EAAA,IAAA,wBAZUD,IAAAA,KAAA,CAAA,CAAA;AAeL,MAAME,IAAoE;AAAA,EAC9E,GAAoC;AAAA,EACpC,GAAoC;AAAA,EACpC,GAAkC;AAAA,EAClC,GAAqC;AAAA;AAAA,EAErC,GAAyC;AAAA,EACzC,GAAyC;AAAA,EACzC,GAA4C;AAAA,EAC5C,GAA4C;AAAA,EAC5C,GAA0C;AAAA,EAC1C,GAA0C;AAAA,EAC1C,IAAgD;AAAA;AAAA,EAEhD,IAAgD;AACnD;AAMO,SAASC,EAAU;AAAA,EACxB,OAAAC;AAAA,EACA,UAAAC,IAAW;AAAA;AACb,GAA2B;AACzB,QAAMC,IAAoB,CAAC,GACrBC,IAAgB,CAACC,MAAyC;AAC1D,IAAA,OAAOA,KAAY,WACbF,EAAA,KAAK,MAAME,IAAU,GAAG,IACvBA,aAAmB,SACpBF,EAAA,KAAKE,EAAQ,MAAM,IAE3BF,EAAQ,KAAKJ,EAAwBM,CAAO,EAAE,MAAM;AAAA,EAExD;AAEI,MAAA,MAAM,QAAQH,CAAQ;AACxB,eAAWG,KAAWH;AACpB,MAAAE,EAAcC,CAAO;AAAA;AAGvB,IAAAD,EAAcF,CAAQ;AAEpB,MAAAC,EAAQ,WAAW;AACd,WAAAF;AAGT,QAAMK,IAAS,IAAI,OAAOH,EAAQ,KAAK,GAAG,GAAG,GAAG,GAC1CI,IAASN,EAAM,QAAQK,GAAQ,EAAE;AACnC,SAAAC,EAAO,WAAW,IACbN,IAEFA,EAAM;AAAA,IACX,IAAI,OAAO,MAAMM,IAAS,KAAK,GAAG;AAAA,IAClC;AAAA,EACF;AACF;"}