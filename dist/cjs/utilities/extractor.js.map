{"version":3,"file":"extractor.js","sources":["../../../src/utilities/extractor.ts"],"sourcesContent":["/**\n * Extractable\n */\nexport type CaptureableCharacterPattern = string | RegExp | CaptureableCharacterType;\n\nexport enum CaptureableCharacterType {\n  HIRAGANA,\n  KUTOUTEN,\n  CHOUON,\n  ZENKAKU_SPACE,\n  HANKAKU_SPACE,\n  ZENKAKU_ALPHABET,\n  HANKAKU_ALPHABET,\n  ZENKAKU_NUMBER,\n  HANKAKU_NUMBER,\n  ZENKAKU_1BYTE_SYMBOL,\n  HANKAKU_1BYTE_SYMBOL,\n}\n\nexport const CaptureableCharacterMap: Record<CaptureableCharacterType, RegExp> = {\n  [CaptureableCharacterType.HIRAGANA]: /[ぁ-ん]/g,\n  [CaptureableCharacterType.KUTOUTEN]: /[、。]/g,\n  [CaptureableCharacterType.CHOUON]: /[ー]/g,\n  /* eslint-disable-next-line no-irregular-whitespace */\n  [CaptureableCharacterType.ZENKAKU_SPACE]: /[　]/g,\n  [CaptureableCharacterType.HANKAKU_SPACE]: /[ ]/g,\n  [CaptureableCharacterType.ZENKAKU_ALPHABET]: /[Ａ-Ｚａ-ｚ]/g,\n  [CaptureableCharacterType.HANKAKU_ALPHABET]: /[A-Za-z]/g,\n  [CaptureableCharacterType.ZENKAKU_NUMBER]: /[０-９]/g,\n  [CaptureableCharacterType.HANKAKU_NUMBER]: /[0-9]/g,\n  [CaptureableCharacterType.ZENKAKU_1BYTE_SYMBOL]: /[！＂＃＄％＆＇（）＊＋，－．／：；＜＝＞？＠［￥］＾＿“｛｜｝～]/g,\n  /* eslint-disable-next-line no-useless-escape*/\n  [CaptureableCharacterType.HANKAKU_1BYTE_SYMBOL]: /[!\"#$%&'()*+,-.\\/:;<=>?@[\\\\]^_`{|}~]/g,\n}\n\nexport type ExtractorInput = {\n  input: string;\n  patterns?: CaptureableCharacterPattern | CaptureableCharacterPattern[];\n}\nexport function extractor({\n  input,\n  patterns = CaptureableCharacterType.HIRAGANA,\n}: ExtractorInput): string {\n  const sources: string[] = []\n  const patternParser = (pattern: CaptureableCharacterPattern) => {\n    if (typeof pattern === 'string') {\n      sources.push('[' + pattern + ']')\n    } else if (pattern instanceof RegExp) {\n      sources.push(pattern.source)\n    } else {\n      sources.push(CaptureableCharacterMap[pattern].source)\n    }\n  }\n\n  if (Array.isArray(patterns)) {\n    for (const pattern of patterns) {\n      patternParser(pattern)\n    }\n  } else {\n    patternParser(patterns)\n  }\n  if (sources.length === 0) {\n    return input\n  }\n\n  const regExp = new RegExp(sources.join('|'), 'g')\n  const filter = input.replace(regExp, '')\n  if (filter.length === 0) {\n    return input\n  }\n  return input.replace(\n    new RegExp('[' + filter + ']', 'g'),\n    '',\n  )\n}\n"],"names":["CaptureableCharacterType","CaptureableCharacterType2","CaptureableCharacterMap","extractor","input","patterns","sources","patternParser","pattern","regExp","filter"],"mappings":"gFAKY,IAAAA,GAAAA,IACVA,EAAAC,EAAA,SAAA,CAAA,EAAA,WACAD,EAAAC,EAAA,SAAA,CAAA,EAAA,WACAD,EAAAC,EAAA,OAAA,CAAA,EAAA,SACAD,EAAAC,EAAA,cAAA,CAAA,EAAA,gBACAD,EAAAC,EAAA,cAAA,CAAA,EAAA,gBACAD,EAAAC,EAAA,iBAAA,CAAA,EAAA,mBACAD,EAAAC,EAAA,iBAAA,CAAA,EAAA,mBACAD,EAAAC,EAAA,eAAA,CAAA,EAAA,iBACAD,EAAAC,EAAA,eAAA,CAAA,EAAA,iBACAD,EAAAC,EAAA,qBAAA,CAAA,EAAA,uBACAD,EAAAC,EAAA,qBAAA,EAAA,EAAA,uBAXUD,IAAAA,GAAA,CAAA,CAAA,EAcL,MAAME,EAAoE,CAC9E,EAAoC,SACpC,EAAoC,QACpC,EAAkC,OAElC,EAAyC,OACzC,EAAyC,OACzC,EAA4C,YAC5C,EAA4C,YAC5C,EAA0C,SAC1C,EAA0C,SAC1C,EAAgD,sCAEhD,GAAgD,uCACnD,EAMO,SAASC,EAAU,CACxB,MAAAC,EACA,SAAAC,EAAW,CACb,EAA2B,CACzB,MAAMC,EAAoB,CAAC,EACrBC,EAAiBC,GAAyC,CAC1D,OAAOA,GAAY,SACbF,EAAA,KAAK,IAAME,EAAU,GAAG,EACvBA,aAAmB,OACpBF,EAAA,KAAKE,EAAQ,MAAM,EAE3BF,EAAQ,KAAKJ,EAAwBM,CAAO,EAAE,MAAM,CAExD,EAEI,GAAA,MAAM,QAAQH,CAAQ,EACxB,UAAWG,KAAWH,EACpBE,EAAcC,CAAO,OAGvBD,EAAcF,CAAQ,EAEpB,GAAAC,EAAQ,SAAW,EACd,OAAAF,EAGT,MAAMK,EAAS,IAAI,OAAOH,EAAQ,KAAK,GAAG,EAAG,GAAG,EAC1CI,EAASN,EAAM,QAAQK,EAAQ,EAAE,EACnC,OAAAC,EAAO,SAAW,EACbN,EAEFA,EAAM,QACX,IAAI,OAAO,IAAMM,EAAS,IAAK,GAAG,EAClC,EACF,CACF"}