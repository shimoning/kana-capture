{"version":3,"file":"extractor.js","sources":["../../../src/utilities/extractor.ts"],"sourcesContent":["/**\n * Extractable\n */\nexport type CapturableCharacterPattern = string | RegExp | CapturableCharacterType;\n\nexport enum CapturableCharacterType {\n  HIRAGANA,\n  KUTOUTEN,\n  CHOUON,\n  KAGIKAKKO,\n  ZENKAKU_SPACE,\n  HANKAKU_SPACE,\n  ZENKAKU_ALPHABET,\n  HANKAKU_ALPHABET,\n  ZENKAKU_NUMBER,\n  HANKAKU_NUMBER,\n  ZENKAKU_1BYTE_SYMBOL,\n  HANKAKU_1BYTE_SYMBOL,\n}\n\nexport const CapturableCharacterMap: Record<CapturableCharacterType, RegExp> = {\n  [CapturableCharacterType.HIRAGANA]: /[ぁ-ん]/g,\n  [CapturableCharacterType.KUTOUTEN]: /[、。]/g,\n  [CapturableCharacterType.CHOUON]: /[ー]/g,\n  [CapturableCharacterType.KAGIKAKKO]: /[「」]/g,\n  /* eslint-disable-next-line no-irregular-whitespace */\n  [CapturableCharacterType.ZENKAKU_SPACE]: /[　]/g,\n  [CapturableCharacterType.HANKAKU_SPACE]: /[ ]/g,\n  [CapturableCharacterType.ZENKAKU_ALPHABET]: /[Ａ-Ｚａ-ｚ]/g,\n  [CapturableCharacterType.HANKAKU_ALPHABET]: /[A-Za-z]/g,\n  [CapturableCharacterType.ZENKAKU_NUMBER]: /[０-９]/g,\n  [CapturableCharacterType.HANKAKU_NUMBER]: /[0-9]/g,\n  [CapturableCharacterType.ZENKAKU_1BYTE_SYMBOL]: /[！＂”＃＄％＆＇’（）＊＋，－．／：；＜＝＞？＠［￥］＾＿｀“｛｜｝～]/g,\n  [CapturableCharacterType.HANKAKU_1BYTE_SYMBOL]: /[!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~]/g,\n}\n\nexport type ExtractorInput = {\n  input: string;\n  patterns?: CapturableCharacterPattern | CapturableCharacterPattern[];\n}\nexport function extractor({\n  input,\n  patterns = CapturableCharacterType.HIRAGANA,\n}: ExtractorInput): string {\n  const regExp = patterns instanceof RegExp\n    ? patterns\n    : generateCapturableRegExp(patterns)\n  const filter = input.replace(regExp, '')\n  if (filter.length === 0) {\n    return input\n  }\n  return input.replace(\n    new RegExp('[' + filter + ']', 'g'),\n    '',\n  )\n}\n\nexport function generateCapturableRegExp(\n  patterns: CapturableCharacterPattern | CapturableCharacterPattern[],\n): RegExp {\n  const sources: string[] = []\n  const _patternParser = (pattern: CapturableCharacterPattern) => {\n    if (typeof pattern === 'string') {\n      sources.push('[' + pattern + ']')\n    } else if (pattern instanceof RegExp) {\n      sources.push(pattern.source)\n    } else {\n      sources.push(CapturableCharacterMap[pattern].source)\n    }\n  }\n\n  if (Array.isArray(patterns)) {\n    for (const pattern of patterns) {\n      _patternParser(pattern)\n    }\n  } else {\n    _patternParser(patterns)\n  }\n  return new RegExp(sources.join('|'), 'g')\n}\n"],"names":["CapturableCharacterType","CapturableCharacterType2","CapturableCharacterMap","extractor","input","patterns","regExp","generateCapturableRegExp","filter","sources","_patternParser","pattern"],"mappings":";;;;;;;;;;;;;;;;;;;;;;sEAKY,IAAAA,GAAAA,IACVA,EAAAC,EAAA,SAAA,CAAA,EAAA,WACAD,EAAAC,EAAA,SAAA,CAAA,EAAA,WACAD,EAAAC,EAAA,OAAA,CAAA,EAAA,SACAD,EAAAC,EAAA,UAAA,CAAA,EAAA,YACAD,EAAAC,EAAA,cAAA,CAAA,EAAA,gBACAD,EAAAC,EAAA,cAAA,CAAA,EAAA,gBACAD,EAAAC,EAAA,iBAAA,CAAA,EAAA,mBACAD,EAAAC,EAAA,iBAAA,CAAA,EAAA,mBACAD,EAAAC,EAAA,eAAA,CAAA,EAAA,iBACAD,EAAAC,EAAA,eAAA,CAAA,EAAA,iBACAD,EAAAC,EAAA,qBAAA,EAAA,EAAA,uBACAD,EAAAC,EAAA,qBAAA,EAAA,EAAA,uBAZUD,IAAAA,GAAA,CAAA,CAAA,EAeL,MAAME,EAAkE,CAC5E,EAAmC,SACnC,EAAmC,QACnC,EAAiC,OACjC,EAAoC,QAEpC,EAAwC,OACxC,EAAwC,OACxC,EAA2C,YAC3C,EAA2C,YAC3C,EAAyC,SACzC,EAAyC,SACzC,GAA+C,yCAC/C,GAA+C,wCAClD,EAMO,SAASC,EAAU,CACxB,MAAAC,EACA,SAAAC,EAAW,CACb,EAA2B,CACzB,MAAMC,EAASD,aAAoB,OAC/BA,EACAE,EAAyBF,CAAQ,EAC/BG,EAASJ,EAAM,QAAQE,EAAQ,EAAE,EACnC,OAAAE,EAAO,SAAW,EACbJ,EAEFA,EAAM,QACX,IAAI,OAAO,IAAMI,EAAS,IAAK,GAAG,EAClC,EACF,CACF,CAEO,SAASD,EACdF,EACQ,CACR,MAAMI,EAAoB,CAAC,EACrBC,EAAkBC,GAAwC,CAC1D,OAAOA,GAAY,SACbF,EAAA,KAAK,IAAME,EAAU,GAAG,EACvBA,aAAmB,OACpBF,EAAA,KAAKE,EAAQ,MAAM,EAE3BF,EAAQ,KAAKP,EAAuBS,CAAO,EAAE,MAAM,CAEvD,EAEI,GAAA,MAAM,QAAQN,CAAQ,EACxB,UAAWM,KAAWN,EACpBK,EAAeC,CAAO,OAGxBD,EAAeL,CAAQ,EAEzB,OAAO,IAAI,OAAOI,EAAQ,KAAK,GAAG,EAAG,GAAG,CAC1C"}