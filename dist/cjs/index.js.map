{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["import { diff } from './utilities/diff'\nimport {\n  CaptureableCharacterPattern,\n  CaptureableCharacterType,\n  generateCaptureableRegExp,\n  extractor,\n} from './utilities/extractor'\nimport { kanaConverter, KanaType } from './utilities/kanaConverter'\nexport { KanaType, CaptureableCharacterType }\nexport type { CaptureableCharacterPattern }\n\nexport type Options = {\n  observeInterval?: number; // unit: ms\n  debug?: boolean; // logging if true\n  realtime?: boolean | HTMLInputElement;\n  enter?: boolean | HTMLInputElement;\n  clearOnInputEmpty?: boolean;\n  captureablePatterns?: CaptureableCharacterPattern | CaptureableCharacterPattern[];\n};\n\n// TODO: support other elements (e.g. HTMLDivElement, HTMLSpanElement, HTMLTextAreaElement)\nexport type OutputElement = Output | HTMLInputElement | string;\nexport type Output = {\n  element: HTMLInputElement;\n  type?: KanaType;\n};\nexport enum OutputTiming {\n  REALTIME, // default and priority\n  ENTER,\n}\n// TODO: support textarea (HTMLTextAreaElement)\nexport type InputElement = HTMLInputElement | string;\nexport function setupObserver(\n  input: InputElement,\n  outputs: OutputElement | OutputElement[],\n  options: Options = {\n    observeInterval: 30,\n    debug: false,\n    realtime: true,\n    enter: false,\n    clearOnInputEmpty: false,\n    captureablePatterns: CaptureableCharacterType.HIRAGANA,\n  },\n) {\n  // 入力値を受け付けるパターン\n  // TODO: support dynamic patterns\n  const captureablePatterns = generateCaptureableRegExp(\n    options.captureablePatterns ?? CaptureableCharacterType.HIRAGANA,\n  )\n\n  // 入力元を整える\n  const inputElement = typeof input === 'string'\n    ? document.querySelector<HTMLInputElement>(input)\n    : input\n  if (!inputElement) {\n    throw new Error('input element not found')\n  }\n\n  // 出力のタイミング\n  let outputTiming = OutputTiming.REALTIME\n  const realtimeIsDynamic = options.realtime instanceof HTMLInputElement\n  const enterIsDynamic = options.enter instanceof HTMLInputElement\n  const outputTimingIsStatic = !realtimeIsDynamic && !enterIsDynamic\n  function _checkOutputTiming() {\n    const realtime =\n      options.realtime &&\n      (options.realtime === true ||\n        (options.realtime instanceof HTMLInputElement && options.realtime.checked))\n    const enter =\n      options.enter &&\n      (options.enter === true ||\n        (options.enter instanceof HTMLInputElement && options.enter.checked))\n    outputTiming = realtime || !enter\n      ? OutputTiming.REALTIME // realtime=true, realtime=false & enter=false\n      : OutputTiming.ENTER  // realtime=false & enter=true\n  }\n  if (outputTimingIsStatic) {\n    _checkOutputTiming()\n  }\n  _debug('outputTiming', { outputTiming, outputTimingIsStatic, realtimeIsDynamic, enterIsDynamic })\n\n  // 出力先を整える\n  const activeOutputs: Required<Output>[] = []\n  const _outputParser = (output: OutputElement): void => {\n    if (typeof output === 'string') {\n      const elements = document.querySelectorAll<HTMLInputElement>(output)\n      for (const element of elements) {\n        activeOutputs.push({ element, type: KanaType.Hiragana })\n      }\n    } else if (output instanceof HTMLInputElement) {\n      activeOutputs.push({ element: output, type: KanaType.Hiragana })\n    } else {\n      activeOutputs.push({\n        element: output.element,\n        type: output.type ?? KanaType.Hiragana,\n      })\n    }\n  }\n  if (Array.isArray(outputs)) {\n    for (const output of outputs) {\n      _outputParser(output)\n    }\n  } else {\n    _outputParser(outputs)\n  }\n\n  // 状態管理\n  let observing: boolean = false\n  let defaultString: string = ''\n  let currentString: string = ''\n\n  let inputValue: string = ''\n  const outputValues: string[] = new Array(activeOutputs.length).fill('')\n  /**\n   * 初期化\n   * @returns void\n   */\n  function _reset() {\n    _debug('reset')\n    defaultString = ''\n    currentString = ''\n\n    inputValue = ''\n    for (let i = 0; i < activeOutputs.length; i++) {\n      outputValues[i] = ''\n    }\n  }\n  /**\n   * 初期入力値を保存する\n   * @returns void\n   */\n  function _setup() {\n    defaultString = inputElement!.value\n    activeOutputs.forEach(({ element }, index) => {\n      outputValues[index] = element.value\n    })\n    _debug('setup', inputElement!.value, { defaultString, activeOutputs })\n  }\n\n  let timer: ReturnType<typeof setInterval> | undefined\n  /**\n   * 監視を開始する\n   * @returns void\n   */\n  function _start() {\n    _debug('start', { timer })\n    if (timer) {\n      return\n    }\n    timer = setInterval(() => {\n      _observe()\n    }, options.observeInterval ?? 30)\n  }\n  /**\n   * 監視を終了する\n   * @returns void\n   */\n  function _end() {\n    _debug('end', { timer })\n    if (timer) {\n      clearInterval(timer)\n      timer = undefined\n    }\n  }\n\n  /**\n   * 入力を監視する\n   * @return void\n   */\n  function _observe() {\n    const inputString = inputElement!.value\n    _debug('observe', { observing, inputString, defaultString, currentString, outputValues })\n\n    // 空文字の場合は何もしない\n    if (inputString === '') {\n      return\n    }\n\n    // すでに入力されている文字を取り除く\n    const diffResult = diff(defaultString, inputString)\n\n    // 同じだったら何もしない\n    if (currentString === diffResult.diff) {\n      return\n    }\n    currentString = diffResult.diff\n\n    // 変換完了している場合は何もしない\n    if (!observing) {\n      return\n    }\n\n    // セットする\n    _set(currentString)\n  }\n\n  /**\n   * セットする\n   * @param string string\n   */\n  function _set(string: string) {\n    _debug('set', { defaultString, string, inputValue, outputValues })\n    const extracted = extractor({\n      input: string,\n      patterns: captureablePatterns,\n    })\n    if (extracted.length === string.length) {\n      inputValue = extracted\n    }\n\n    activeOutputs.forEach(({ element, type }, index) => {\n      const converted = kanaConverter(type, inputValue)\n      _debug('converted', { type, string, inputValue, after: converted, before: outputValues[index], bufferKana: element.dataset['bufferKana'], bufferOther: element.dataset['bufferOther'] })\n      if (outputTiming === OutputTiming.REALTIME) {\n        element.value = outputValues[index] + converted\n      } else if (outputTiming === OutputTiming.ENTER) {\n        _setBuffer(element, converted)\n      }\n    })\n  }\n\n  /**\n   * 文字を反映せずに一時保存する\n   *\n   * @param element HTMLInputElement\n   * @param string  string\n   * @returns void\n   */\n  function _setBuffer(element: HTMLInputElement, string: string) {\n    if (observing) {\n      element.dataset['bufferKana'] = string\n    } else {\n      element.dataset['bufferOther'] = (element.dataset['bufferOther'] ?? '') + string\n    }\n  }\n  /**\n   * バッファをクリアする\n   * @param element HTMLInputElement\n   * @returns void\n   */\n  function _clearBuffer(element: HTMLInputElement) {\n    console.log('clear buffer')\n    element.dataset['bufferOther'] = ''\n    element.dataset['bufferKana'] = ''\n  }\n  // 予約\n  // /**\n  //  * 全てのバッファをクリアする\n  //  * @returns void\n  //  */\n  // function _clearBufferAll() {\n  //   activeOutputs.forEach(({ element }) => {\n  //     _clearBuffer(element)\n  //   })\n  // }\n  /**\n   * 反映する\n   * @returns void\n   */\n  function _reflectBufferAll(clear: boolean = false) {\n    activeOutputs.forEach(({ element }) => {\n      if (clear) {\n        element.value = ''\n        _clearBuffer(element)\n        return\n      }\n      const buffer = (element.dataset['bufferOther'] ?? '') + (element.dataset['bufferKana'] ?? '')\n      if (buffer) {\n        element.value += buffer\n        _clearBuffer(element)\n      }\n    })\n  }\n\n  /**\n   * デバッグログ\n   * @param message\n   * @param args\n   * @return void\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function _debug(message: string, ...args: any[]) {\n    if (!options.debug) {\n      return\n    }\n    if (args.length === 0) {\n      console.info('debug', { message })\n      return\n    }\n    console.info('debug', { message }, ...args)\n  }\n\n  /**\n   * Event listeners\n   */\n  inputElement.addEventListener('focus', () => {\n    _debug('focus')\n    _setup()\n  })\n  inputElement.addEventListener('blur', () => {\n    _debug('blur')\n    _end()\n  })\n  inputElement.addEventListener('compositionstart', (e: CompositionEvent) => {\n    _debug('compositionstart', { e })\n    _setup()\n    _start()\n    observing = true\n  })\n  inputElement.addEventListener('compositionend', (e: CompositionEvent) => {\n    _debug('compositionend', { e })\n    _end()\n    _set(inputValue)\n    _reset()\n    observing = false\n  })\n  inputElement.addEventListener('beforeinput', (e: InputEvent) => {\n    _debug('beforeinput', { observing, e })\n    if (!observing && !e.isComposing && e.data) {\n      const candidate = e.data\n      const extracted = extractor({\n        input: candidate,\n        patterns: captureablePatterns,\n      })\n      if (candidate && candidate === extracted) {\n        _setup()\n        _set(candidate)\n      }\n    }\n  })\n  inputElement.addEventListener('keyup', (e: KeyboardEvent) => {\n    _debug('keyup', e.code, { observing, e })\n    if (e.code === 'Enter') {\n      let clear = false\n      if (options.clearOnInputEmpty && inputElement.value === '') {\n        clear = true\n        _reset()\n        _set('')\n      }\n      if (outputTiming === OutputTiming.ENTER) {\n        _reflectBufferAll(clear)\n      }\n    }\n    if (e.code === 'Backspace') {\n      // FIXME: REALTIME -> 日本語入力中にバックスペースで全て消すと1文字目が残る\n      // FIXME: ENTER -> 途中入力状態で、日本語入力中にバックスペースで全て消し、Enterで確定もしくは半角入力後エンターすると1文字目が残る\n      _debug('backspace', { outputTiming }, inputElement.value)\n    }\n  })\n\n  if (options.realtime instanceof HTMLInputElement) {\n    options.realtime.addEventListener('change', () => {\n      _debug('realtime change')\n      _checkOutputTiming()\n      _reflectBufferAll()\n    })\n  }\n  if (options.enter instanceof HTMLInputElement) {\n    options.enter.addEventListener('change', () => {\n      _debug('enter change')\n      _checkOutputTiming()\n    })\n  }\n}\n"],"names":["OutputTiming","OutputTiming2","setupObserver","input","outputs","options","CaptureableCharacterType","captureablePatterns","generateCaptureableRegExp","inputElement","outputTiming","realtimeIsDynamic","enterIsDynamic","outputTimingIsStatic","_checkOutputTiming","realtime","enter","_debug","activeOutputs","_outputParser","output","elements","element","KanaType","observing","defaultString","currentString","inputValue","outputValues","_reset","i","_setup","index","timer","_start","_observe","_end","inputString","diffResult","diff","_set","string","extracted","extractor","type","converted","kanaConverter","_setBuffer","_clearBuffer","_reflectBufferAll","clear","buffer","message","args","candidate"],"mappings":"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"}