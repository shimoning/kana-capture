{"version":3,"file":"extractor.js","sources":["../../../src/utilities/extractor.ts"],"sourcesContent":["/**\n * Extractable\n */\nexport type CapturableCharacterPattern = string | RegExp | CapturableCharacterType;\n\nexport enum CapturableCharacterType {\n  HIRAGANA,\n  KUTOUTEN,\n  CHOUON,\n  KAGIKAKKO,\n  ZENKAKU_SPACE,\n  HANKAKU_SPACE,\n  ZENKAKU_ALPHABET,\n  HANKAKU_ALPHABET,\n  ZENKAKU_NUMBER,\n  HANKAKU_NUMBER,\n  ZENKAKU_1BYTE_SYMBOL,\n  HANKAKU_1BYTE_SYMBOL,\n}\n\nexport const CapturableCharacterMap: Record<CapturableCharacterType, RegExp> = {\n  [CapturableCharacterType.HIRAGANA]: /[ぁ-ん]/g,\n  [CapturableCharacterType.KUTOUTEN]: /[、。]/g,\n  [CapturableCharacterType.CHOUON]: /[ー]/g,\n  [CapturableCharacterType.KAGIKAKKO]: /[「」]/g,\n  /* eslint-disable-next-line no-irregular-whitespace */\n  [CapturableCharacterType.ZENKAKU_SPACE]: /[　]/g,\n  [CapturableCharacterType.HANKAKU_SPACE]: /[ ]/g,\n  [CapturableCharacterType.ZENKAKU_ALPHABET]: /[Ａ-Ｚａ-ｚ]/g,\n  [CapturableCharacterType.HANKAKU_ALPHABET]: /[A-Za-z]/g,\n  [CapturableCharacterType.ZENKAKU_NUMBER]: /[０-９]/g,\n  [CapturableCharacterType.HANKAKU_NUMBER]: /[0-9]/g,\n  [CapturableCharacterType.ZENKAKU_1BYTE_SYMBOL]: /[！＂”＃＄％＆＇’（）＊＋，－．／：；＜＝＞？＠［￥］＾＿｀“｛｜｝～]/g,\n  [CapturableCharacterType.HANKAKU_1BYTE_SYMBOL]: /[!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~]/g,\n}\n\nexport type ExtractorInput = {\n  input: string;\n  patterns?: CapturableCharacterPattern | CapturableCharacterPattern[];\n}\nexport function extractor({\n  input,\n  patterns = CapturableCharacterType.HIRAGANA,\n}: ExtractorInput): string {\n  const regExp = patterns instanceof RegExp\n    ? patterns\n    : generateCapturableRegExp(patterns)\n  const filter = input.replace(regExp, '')\n  if (filter.length === 0) {\n    return input\n  }\n  return input.replace(\n    new RegExp('[' + filter + ']', 'g'),\n    '',\n  )\n}\n\nexport function generateCapturableRegExp(\n  patterns: CapturableCharacterPattern | CapturableCharacterPattern[],\n): RegExp {\n  const sources: string[] = []\n  const _patternParser = (pattern: CapturableCharacterPattern) => {\n    if (typeof pattern === 'string') {\n      sources.push('[' + pattern + ']')\n    } else if (pattern instanceof RegExp) {\n      sources.push(pattern.source)\n    } else {\n      sources.push(CapturableCharacterMap[pattern].source)\n    }\n  }\n\n  if (Array.isArray(patterns)) {\n    for (const pattern of patterns) {\n      _patternParser(pattern)\n    }\n  } else {\n    _patternParser(patterns)\n  }\n  return new RegExp(sources.join('|'), 'g')\n}\n"],"names":["CapturableCharacterType","CapturableCharacterType2","CapturableCharacterMap","extractor","input","patterns","regExp","generateCapturableRegExp","filter","sources","_patternParser","pattern"],"mappings":"AAKY,IAAAA,sBAAAA,OACVA,EAAAC,EAAA,WAAA,CAAA,IAAA,YACAD,EAAAC,EAAA,WAAA,CAAA,IAAA,YACAD,EAAAC,EAAA,SAAA,CAAA,IAAA,UACAD,EAAAC,EAAA,YAAA,CAAA,IAAA,aACAD,EAAAC,EAAA,gBAAA,CAAA,IAAA,iBACAD,EAAAC,EAAA,gBAAA,CAAA,IAAA,iBACAD,EAAAC,EAAA,mBAAA,CAAA,IAAA,oBACAD,EAAAC,EAAA,mBAAA,CAAA,IAAA,oBACAD,EAAAC,EAAA,iBAAA,CAAA,IAAA,kBACAD,EAAAC,EAAA,iBAAA,CAAA,IAAA,kBACAD,EAAAC,EAAA,uBAAA,EAAA,IAAA,wBACAD,EAAAC,EAAA,uBAAA,EAAA,IAAA,wBAZUD,IAAAA,KAAA,CAAA,CAAA;AAeL,MAAME,IAAkE;AAAA,EAC5E,GAAmC;AAAA,EACnC,GAAmC;AAAA,EACnC,GAAiC;AAAA,EACjC,GAAoC;AAAA;AAAA,EAEpC,GAAwC;AAAA,EACxC,GAAwC;AAAA,EACxC,GAA2C;AAAA,EAC3C,GAA2C;AAAA,EAC3C,GAAyC;AAAA,EACzC,GAAyC;AAAA,EACzC,IAA+C;AAAA,EAC/C,IAA+C;AAClD;AAMO,SAASC,EAAU;AAAA,EACxB,OAAAC;AAAA,EACA,UAAAC,IAAW;AAAA;AACb,GAA2B;AACzB,QAAMC,IAASD,aAAoB,SAC/BA,IACAE,EAAyBF,CAAQ,GAC/BG,IAASJ,EAAM,QAAQE,GAAQ,EAAE;AACnC,SAAAE,EAAO,WAAW,IACbJ,IAEFA,EAAM;AAAA,IACX,IAAI,OAAO,MAAMI,IAAS,KAAK,GAAG;AAAA,IAClC;AAAA,EACF;AACF;AAEO,SAASD,EACdF,GACQ;AACR,QAAMI,IAAoB,CAAC,GACrBC,IAAiB,CAACC,MAAwC;AAC1D,IAAA,OAAOA,KAAY,WACbF,EAAA,KAAK,MAAME,IAAU,GAAG,IACvBA,aAAmB,SACpBF,EAAA,KAAKE,EAAQ,MAAM,IAE3BF,EAAQ,KAAKP,EAAuBS,CAAO,EAAE,MAAM;AAAA,EAEvD;AAEI,MAAA,MAAM,QAAQN,CAAQ;AACxB,eAAWM,KAAWN;AACpB,MAAAK,EAAeC,CAAO;AAAA;AAGxB,IAAAD,EAAeL,CAAQ;AAEzB,SAAO,IAAI,OAAOI,EAAQ,KAAK,GAAG,GAAG,GAAG;AAC1C;"}